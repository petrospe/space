<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Black Hole with Accretion Disk</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; }

    #exit-button {
      position: absolute;
      top: 15px;
      right: 20px;
      font-size: 28px;
      font-weight: bold;
      color: white;
      cursor: pointer;
      z-index: 999;
      background: rgba(0, 0, 0, 0.5);
      padding: 6px 10px;
      border-radius: 8px;
      transition: background 0.2s;
    }
    #exit-button:hover {
      background: rgba(255, 0, 0, 0.7);
    }
  </style>
</head>
<body>
  <div id="exit-button">âœ–</div>
  <script>
    function loadScript(src, callback) {
      const script = document.createElement('script');
      script.src = src;
      script.onload = callback;
      document.head.appendChild(script);
    }

    loadScript('https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js', () => {
      loadScript('https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js', initApp);
    });

    function initApp() {
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 15, 30);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 10;
        controls.maxDistance = 100;

        // Minimal ambient light
        scene.add(new THREE.AmbientLight(0x000000));

        // ðŸŒŒ Galaxy Background
        const loader = new THREE.TextureLoader();
        loader.load('images/starmap_random_2020_4k_gal.png', texture => {
            const bgGeo = new THREE.SphereGeometry(500, 64, 64);
            const bgMat = new THREE.MeshBasicMaterial({ 
                map: texture, 
                side: THREE.BackSide 
            });
            const background = new THREE.Mesh(bgGeo, bgMat);
            scene.add(background);
            background.position.set(0, 0, 0);
        });

        // âœ¨ Distant Stars
        const starTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');
        const starMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.3,
            map: starTexture,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const starCount = 2000;
        const starPositions = [];
        for (let i = 0; i < starCount; i++) {
            const r = Math.random() * 100 + 30;
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);
            starPositions.push(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.sin(phi) * Math.sin(theta),
                r * Math.cos(phi)
            );
        }

        const starGeometry = new THREE.BufferGeometry().setAttribute(
            'position',
            new THREE.Float32BufferAttribute(starPositions, 3)
        );
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // ðŸ•³ï¸ Black Hole Event Horizon (dark sphere)
        const eventHorizonGeo = new THREE.SphereGeometry(2, 64, 64);
        const eventHorizonMat = new THREE.MeshBasicMaterial({ 
            color: 0x000000,
            side: THREE.DoubleSide
        });
        const eventHorizon = new THREE.Mesh(eventHorizonGeo, eventHorizonMat);
        scene.add(eventHorizon);

        // ðŸŒŸ Accretion Disk - Multi-layered with Doppler effect
        const blackHoleGroup = new THREE.Group();
        scene.add(blackHoleGroup);

        // Inner hot accretion disk (closer to event horizon)
        const innerDiskGeo = new THREE.RingGeometry(2.2, 4, 128);
        const innerDiskMat = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.9,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending
        });
        const innerDisk = new THREE.Mesh(innerDiskGeo, innerDiskMat);
        innerDisk.rotation.x = Math.PI / 2;
        blackHoleGroup.add(innerDisk);

        // Middle accretion disk (orange/red)
        const middleDiskGeo = new THREE.RingGeometry(4, 8, 128);
        const middleDiskMat = new THREE.MeshBasicMaterial({
            color: 0xff6b35,
            transparent: true,
            opacity: 0.8,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending
        });
        const middleDisk = new THREE.Mesh(middleDiskGeo, middleDiskMat);
        middleDisk.rotation.x = Math.PI / 2;
        blackHoleGroup.add(middleDisk);

        // Outer accretion disk (red)
        const outerDiskGeo = new THREE.RingGeometry(8, 15, 128);
        const outerDiskMat = new THREE.MeshBasicMaterial({
            color: 0xff0000,
            transparent: true,
            opacity: 0.7,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending
        });
        const outerDisk = new THREE.Mesh(outerDiskGeo, outerDiskMat);
        outerDisk.rotation.x = Math.PI / 2;
        blackHoleGroup.add(outerDisk);

        // ðŸŒŸ Accretion Disk Glow (Doppler effect - brighter on approaching side)
        const glowDiskGeo = new THREE.RingGeometry(2.1, 16, 128);
        const glowDiskMat = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.4,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending
        });
        const glowDisk = new THREE.Mesh(glowDiskGeo, glowDiskMat);
        glowDisk.rotation.x = Math.PI / 2;
        blackHoleGroup.add(glowDisk);

        // ðŸ”¥ Particle Streams (matter falling into black hole)
        const particleCount = 500;
        const particlePositions = [];
        const particleVelocities = [];
        const particleSizes = [];

        for (let i = 0; i < particleCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 3 + Math.random() * 12;
            const height = (Math.random() - 0.5) * 2;
            
            particlePositions.push(
                Math.cos(angle) * radius,
                height,
                Math.sin(angle) * radius
            );
            
            particleVelocities.push(
                -Math.cos(angle) * 0.01,
                0,
                -Math.sin(angle) * 0.01
            );
            
            particleSizes.push(0.05 + Math.random() * 0.1);
        }

        const particleGeometry = new THREE.BufferGeometry();
        particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(particlePositions, 3));
        particleGeometry.setAttribute('size', new THREE.Float32BufferAttribute(particleSizes, 1));

        const particleMaterial = new THREE.PointsMaterial({
            color: 0x00ffff,
            size: 0.2,
            map: starTexture,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const particles = new THREE.Points(particleGeometry, particleMaterial);
        blackHoleGroup.add(particles);

        // ðŸŒŸ Photon Sphere (light orbiting the black hole)
        const photonSphereGeo = new THREE.RingGeometry(3, 3.1, 64);
        const photonSphereMat = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending
        });
        const photonSphere = new THREE.Mesh(photonSphereGeo, photonSphereMat);
        photonSphere.rotation.x = Math.PI / 2;
        blackHoleGroup.add(photonSphere);

        // ðŸŒŸ Corona/Atmosphere around event horizon
        const coronaGeo = new THREE.SphereGeometry(2.1, 64, 64);
        const coronaMat = new THREE.MeshBasicMaterial({
            color: 0xffaa00,
            transparent: true,
            opacity: 0.2,
            side: THREE.BackSide,
            blending: THREE.AdditiveBlending
        });
        const corona = new THREE.Mesh(coronaGeo, coronaMat);
        blackHoleGroup.add(corona);

        // ðŸŒŸ Gravitational Lensing Effect (distorted ring)
        const lensingRings = [];
        for (let i = 0; i < 3; i++) {
            const ringGeo = new THREE.RingGeometry(2.5 + i * 0.3, 2.6 + i * 0.3, 64);
            const ringMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.1 - i * 0.03,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = Math.PI / 2;
            blackHoleGroup.add(ring);
            lensingRings.push(ring);
        }

        // ðŸŒŸ Accretion Disk Hot Spots
        const hotSpotCount = 8;
        const hotSpots = [];
        for (let i = 0; i < hotSpotCount; i++) {
            const spotGeo = new THREE.SphereGeometry(0.3, 16, 16);
            const spotMat = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            const spot = new THREE.Mesh(spotGeo, spotMat);
            const angle = (i / hotSpotCount) * Math.PI * 2;
            const radius = 5;
            spot.position.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);
            blackHoleGroup.add(spot);
            hotSpots.push({ mesh: spot, angle: angle, radius: radius });
        }

        // ðŸŽ¬ Animation
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // Rotate accretion disks at different speeds (inner faster)
            innerDisk.rotation.z += 0.05;
            middleDisk.rotation.z += 0.03;
            outerDisk.rotation.z += 0.02;
            glowDisk.rotation.z += 0.04;
            photonSphere.rotation.z += 0.01;

            // Rotate lensing rings
            lensingRings.forEach((ring, i) => {
                ring.rotation.z += 0.01 * (i + 1);
            });

            // Animate particles falling in
            const positions = particleGeometry.attributes.position.array;
            const sizes = particleGeometry.attributes.size.array;
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const x = positions[i3];
                const y = positions[i3 + 1];
                const z = positions[i3 + 2];
                
                const distance = Math.sqrt(x * x + y * y + z * z);
                
                if (distance < 2.5) {
                    // Reset particle to outer edge
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 12 + Math.random() * 3;
                    const height = (Math.random() - 0.5) * 2;
                    positions[i3] = Math.cos(angle) * radius;
                    positions[i3 + 1] = height;
                    positions[i3 + 2] = Math.sin(angle) * radius;
                } else {
                    // Pull particle toward center
                    const pullStrength = 0.02 / (distance * distance);
                    positions[i3] -= x * pullStrength;
                    positions[i3 + 1] -= y * pullStrength * 0.5;
                    positions[i3 + 2] -= z * pullStrength;
                }
            }
            
            particleGeometry.attributes.position.needsUpdate = true;

            // Animate hot spots
            hotSpots.forEach(spot => {
                spot.angle += 0.02;
                spot.mesh.position.x = Math.cos(spot.angle) * spot.radius;
                spot.mesh.position.z = Math.sin(spot.angle) * spot.radius;
                
                // Pulsing brightness
                const pulse = Math.sin(time * 5 + spot.angle) * 0.3 + 0.7;
                spot.mesh.material.opacity = pulse * 0.8;
            });

            // Pulsing corona
            const coronaPulse = Math.sin(time * 3) * 0.1 + 0.2;
            corona.material.opacity = coronaPulse;
            corona.scale.setScalar(1 + Math.sin(time * 2) * 0.05);

            // Rotate entire black hole system slowly
            blackHoleGroup.rotation.y += 0.001;

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    }
   
    document.getElementById('exit-button').addEventListener('click', () => {
      window.location.href = 'index.html';
    });
  </script>
</body>
</html>

